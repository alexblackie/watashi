<!doctype html>
<head lang="en">
  <meta charset="UTF-8">
  <title>Mix You an Elixir &mdash; Alex Blackie</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/?family=Source+Code+Pro:400">
  <style type="text/css">
    body {
      white-space: pre;
      font-family: monospace;
      line-height: 1.3em;
    }
  </style>
</head>

<body>


                               MIX YOU AN ELIXIR
                                FOR MOSTLY GOOD

                                  Alex Blackie
                                 December 2014

                                     * * *

1. AN ERLANG HISTORY IN BRIEF

    In the 1980's, a project began in Ericsson Labs. A few wonderful nerds set
    on a project to find the perfect programming language. To quote Joe
    Armstrong, "[Erlang] was kind of an accident, really."

    Nothing really satisfied their demands of high concurrency and fault
    tolerance. They took bits of Prolog and bits of Smalltalk and accidentally
    invented a programming language.

    It wasn't until 1998 that Erlang found its first production use: AXD301
    telephony switch. This is the product that introduced the idea of "nine
    nines" of uptime (which equates to about 32 miliseconds of downtime per
    year).

    1998 also marked the year Ericsson open-sourced Erlang, but not before first
    banning its use internally and losing Joe Armstrong in the process. Once
    open-sourced, Ericsson lifted the ban, and in 2004 Joe Armstrong found his
    way back.

    And now, Erlang is growing even faster, finding itself as relevant as ever
    in the new "webscale cloud 3.0" landscape. Companies and products like
    Facebook and Whatsapp have thrown their weight behind it, and its popularity
    and usefulness has only increased with age. Erlang is the fine wine of
    programming languages.

3. BUT WHY

    Many have tried to clone the ideas of Erlang, but none can match the fact
    that Erlang's implementations are in the kernel itself. This is quite
    possibly one of the primary reasons to use Erlang over an add-on type
    library like Akka.

    When the concepts of fault-tolerance and distribution are part of the
    language's kernel itself, it influences the way you think about and build
    your applications. Whereas with Akka, you might try to add-on distribution
    to a legacy Java app, or perhaps still approach the design of your system
    from a Java perspective. With Erlang, you don't have a choice but to design
    a system that takes advantage of the immense power provided by the Erlang
    standard library.

4. BUT ELIXIR

    The easiest way to think of Elixir is: Elixir is to Erlang as coffeescript
    is to javascript. Elixir, in the end, runs on the Erlang VM and compiles
    into Erlang bytecode, but provides a prettier face and some nice shortcuts
    on top. It's the icing on the Erlang cake.

    Since Elixir is, in effect, still just Erlang, a working knowledge of
    Erlang-proper will immensely help in understanding and troubleshooting,
    especially the particularly beautiful error messages one often finds
    themselves upon.

    Elixir came on to the scene a couple years back, in 2012. It promised to
    take the power of the Erlang VM and toolchain and slap a more modern (read:
    Ruby-like) face on it... It worked, and recently the language has reached
    1.0 and is growing extremely quickly.

5. INSTALLATION AND SETUP

    5.1. INSTALLING ERLANG

        We need the Erlang runtime to be installed, even for Elixir.

        ASIDE: As a shameless self-plug, you can skip all this and use Vagrant
        using my own base template, available on the Vagrant Cloud as
        `alexblackie/basicelixir`.

        A lot of Linux distributions have Erlang in their repositories, but it
        is usually grossly out-of-date; Elixir requires we use Erlang R17 or
        greater, so unless you're using a rolling distro you likely won't be
        able to use the repositories for this. Luckily, Erlang Solutions (a
        company founded by one of the co-creators of Erlang), provides
        repositories for all major distros[1].

        If you're using OS X, installing through Homebrew will likely be
        easiest, and as of writing it has the latest version. Alternatively,
        Erlang Solutions also provides[1] and OS X installer if Homebrew isn't
        your thing.

        If you're using Windows, please re-evaluate your decisions.

        Once installed, make sure it's working by typing `erl` -- you should be
        dropped at an interactive REPL. If it boots without error, you can
        safely quit by hitting `CTRL-G` and typing `q <ENTER>`. Or you can
        brutally kill by hitting `CTRL-C` twice.

    5.2. INSTALLING ELIXIR

        Elixir is actually quite easy to install.

        If you're running OS X or Linux, you can download the latest
        `Precompiled.zip` from the Github Releases page[2]. Extract it somewhere
        (I usually use `$HOME/.elixir`), and then add the `bin` folder to your
        `$PATH`.

        For OS X, you can alternatively just install it through Homebrew as
        well.

        For Windows, I still recommend re-evaluating your decisions.

        Once installed, you can test by opening the interactive shell with
        `iex`. If successful, you can quit it the same way you quit `erl`.

    5.3. DECORATING

        You'll likely need to add Elixir syntax support to whatever editor you
        use. Below are some links to the official plugins for some editors,
        though you'll likely only want the Vim one because you're all using Vim,
        right?

        case editor do
          vim     -> https://github.com/elixir-lang/vim-elixir
          emacs   -> https://github.com/elixir-lang/emacs-elixir
          sublime -> https://github.com/elixir-lang/elixir-tmbundle
          atom    -> https://github.com/lucasmazza/language-elixir
          gedit   -> https://github.com/SteffenBauer/elixir-gtksourceview
        end

6. LET'S GO ALREADY

    Enough history and setup, let's actually get to building our first
    Elixir app! I chose Elixir for this instead of Erlang simply because I feel
    that with Elixir's "Mix" tool, it makes getting started a lot easier and
    faster.

    6.1. THE PROJECT

        We're going to build a simple web application that greets whomever we
        tell it. The name will be given as a query string, and we'll even add
        some fallbacks for 404 or bad requests. If you like, you can download a
        finished example for cheatin–er–reference[3].

        For the honest amoung you, let's continue...

    6.2. PLANNING IT OUT

        Our application is going to be pretty minimal, but planning out how
        everything's going to fit together is always a worthwhile step.

        The intended behaviour is to respond to a GET request on the root path,
        simply returning a greeting for the name given. For example:

            $ curl http://localhost:4000/?name=Bob
            hello bob!%

        Our module hierarchy is going to look something like this:

            - SayIt
                - SayIt.Supervisor
                - SayIt.Router

        Notice the supervisor. We're going to use one of Erlang's most powerful
        fault-tolerance features and supervise the router. This means if the
        router crashes or dies somehow, the supervisor will catch that and
        restart it. This is one of the features that contributes to the
        "nine-nines" of uptime.

        Our "supervision tree" will look something like this:

            - SayIt.Supervisor
                - SayIt.Router

        It is likely overkill to use a supervisor for literally one module that
        does pretty close to nothing, but it's good to get in the habit of
        basically supervising everything you can. Plus this isn't exactly a
        production project (I hope).

    6.3. GENERATION MIX

        "Mix" is the project-management tool for Elixir. It helps you manage
        dependencies, compilation, environments, and tasks. It also can create a
        skeleton project structure for us:

            $ mix new say_it

        Note the underscore. Mix will generate our module name from the
        snake-cased name we provide here. Your application's module will be a
        sentence-cased variation, while this snake-case variant will be the atom
        reference used by the Erlang VM. You don't really have to worry about
        any of this yet, but basically if you want your project module to be
        capitalized correctly (`SayIt` instead of `Sayit`), make sure you snake
        correctly.

        Alternatively, we could specify the module name if we want it to be
        different from the application name:

            $ mix new chatbus --module ChatBus

        Mix should create a structure similar to this:

            say_it/
            ├── README.md
            ├── config/
            │   └── config.exs
            ├── lib/
            │   └── say_it.ex
            ├── mix.exs
            └── test/
                ├── say_it_test.exs
                    └── test_helper.exs

        Change into the newly created directory, open it in your favourite editor
        (Vim), and let's get started.

    6.4. SUPERVISING AND BEHAVING

        The fault-tolerance in Erlang comes from the supervision tree. If a
        process dies, you can instruct the supervisor to do a few different
        things, the most common being to just restart the process.

        Mix so nicely created a `lib` directory with a stub application file for
        us. Since our application is so small, we're just going to dump
        everything in `lib`, but generally it's better to create a directory to
        hold nested modules (in this case, the directory would be `say_it`).

        Let's create `lib/supervisor.ex`.

        First, define the module:

            defmodule SayIt.Supervisor do

            end

        Then, let's use the `Supervisor` behaviour. A behaviour is essentially a
        specification, ensuring that certain callbacks are present and that a
        specific structure is followed.

        In Elixir, we use `use/2`, which is an extension of the basic Erlang
        behaviour system. Elixir's `use` is a shortcut that requires the given
        module into the current one while maintaining namespace, thereby
        allowing access to its macros and functions, but without overriding any
        of our functions. Elixir's `Supervisor` provides a couple helper
        functions and sane defaults to make our lives easier.

        To tell it to import the Supervisor behaviour, simply:

            defmodule SayIt.Supervisor do
              use Supervisor

            end

        Unfortunately, we're not quite done yet.

        Erlang has a concept known as "linking" -- essentially, starting a
        module from anoter module. Linking is the easiest way to get a process
        running, but also means that if the linkee crashes, so will the parent
        linker.

        To start our Supervisor, we need to add a `start_link/0` function to it,
        so we can link it to our application module. This is pretty simple:

            defmodule SayIt.Supervisor do
              use Supervisor

              def start_link do
                Supervisor.start_link(__MODULE__, [])
              end
            end

        The `start_link` function should be lean, only starting the things it
        needs to function, and ending with a call to start the supervisor. In
        this case, we need to start nothing but the supervisor itself, so we now
        link to Elixir's `Supervisor` module (the one we just `use`d).
        `__MODULE__` is a reference to the current module name, and the second
        parameter is a list of options, in this case none.

        But we're still not quite done.

        We still need to define our "child specs." Basically, a list of modules
        that the supervisor will automatically start and watch over. Usually
        child specs are a mess of tuples in tuples in tuples, but Elixir's
        Supervisor behaviour abstracts away most of that pain. Let's add an
        empty list just to get the skeleton in place.

        The Supervisor specification requires an `init/1` function to be
        present, its return value being the child spec. The one argument to
        `init/1` being the options list we passed as the last argument in
        `start_link/0`.

            defmodule SayIt.Supervisor do
              use Supervisor

              def start_link do
                Supervisor.start_link(__MODULE__, [])
              end

              def init(_opts) do
                children = []
                supervise(children, strategy: :one_for_one)
              end
            end

        Let's break down what's going on here:

            `_opts`       Variables prefixed with an underscore mean we know
                          this argument is unused, but we do not want to change
                          the arity of the function by removing it. It's
                          essentially a sign to the compiler to stop whining
                          about unused variables.

            `supervise`   This function is provided by Elixir, and it generates
                          the nasty tuple-centipede that Erlang wants. The first
                          argument is the list of children, the second is a list
                          of supervision options, in this case the strategy.

        We're using the `one_for_one` strategy here, which basically means if
        one module crashes, we'll restart that one module. There are other
        options, one of the other most-used being restarting all children if one
        dies (`one_for_all`).

        Notice how the "list" of options doesn't actually look like a list. This
        is a nice Elixir shorthand syntax for a list of tuples. For a
        side-by-side comparison:

            strategy: :one_for_one      -vs-       [{:strategy, :one_for_one}]

        Both are correct, just one is slightly more readable. I'll leave it up
        to you to decide which you prefer. Note that the former syntax can be
        wrapped in a list if needed (`[strategy: :etc]`).

        Now that we have a supervisor, we can start it from the application
        module. Mix created a pretty barebones skeleton for us, so we'll need to
        add both the `Application` behaviour and the `start/2` callback. Open up
        `lib/say_it.ex` and link the supervisor:

            def SayIt do
              use Application

              def start(_type, _args) do
                SayIt.Supervisor.start_link()
              end
            end

        Phew. Now we have a supervisor... Mostly. We're not actually supervising
        anything yet, so let's get started building something to supervise.

    6.5. WRITING THE ROUTER

        We're going to use an Elixir library called Plug to handle the HTTP
        connections. Plug is middleware that just wraps the Erlang `cowboy`
        library, but provides a nicer API and more Elixir-like configuration
        style.

        Elixir has its own package repository, hex.pm. When you add a dependency
        to the list, by default it will search Hex for that package name and
        version. Alternatively, you can provide a repository URL or Github
        repository to pull from if Hex doesn't have the package or it's
        out-of-date.

        So let's add Plug. Open up `mix.exs` and add `:plug` and `:cowboy` to
        the `deps` list.

            defp deps do
              [
                {:cowboy, "~> 1.0.0"},
                {:plug, "~> 0.8.4"}
              ]
            end

        Then update the dependencies:

            $ mix deps.get

        Now let's get routing.

        The router will be pretty basic. We just need to add a GET handler and
        do some parsing.

        Let's create a basic module, `lib/router.ex`, and use the `Plug.Router`
        behaviour:

            defmodule SayIt.Router do
              use Plug.Router

            end

        Now we just need to add our route handler. First, we need to import a
        couple plugs. Plug is modular, so we need to actually specify the
        "plugs" we want to use.

            defmodule SayIt.Router do
              use Plug.Router

              plug :match
              plug :dispatch

            end

        The `:match` plug allows us to pattern-match against request URLs and
        the `:dispatch` plug allows us to execute code in blocks under each
        matched route.

        So let's add our route. We just need to add a `get` block for this. For
        now, we'll just hard-code a "hello world" message to demonstrate:

            defmodule SayIt.Router do
              use Plug.Router

              plug :match
              plug :dispatch

              get "/" do
                send_resp(conn, 200, "hello world!")
              end

              match _ do
                send_resp(conn, 404, "not found")
              end
            end

        One thing to note here: Plug is highly abstract; this is not normal
        Elixir code, this is a custom macro-powered  DSL that Plug provides. If
        you're confused about where `conn` is coming from, just assume it's
        magic, because it bascally is.

        So all we're doing in this `get` block is sending a response code 200,
        with the plain-text body of "hello world!".

        Our router is basically done, we just need to add it to the supervision
        tree. Open up `lib/supervisor.ex` again, and add this module to the
        children list:

            children = [
              worker(SayIt.Router, [])
            ]

        However, Plug does not provide a `start_link/0/` for us, so we need to
        add one. Open up our `lib/router.ex` again, and add the `start_link`:

            def start_link do
              Plug.Adapters.Cowboy.http __MODULE__, []
            end

        Here, we're invoking the Plug webserver, telling it to start the current
        module (remember `__MODULE__` is a reference to the current module).

        I think it's about time we ran our application.

    6.6. RUNNING THE APP

        If you didn't make any typos (i.e., if you're perfect like me), then
        everything should "just work™".

        There are two ways to run your app, either through `mix` or `iex`. Both
        work exactly the same, just one drops you at a shell, and the other just
        waits forever. I generally prefer the `iex` approach, as it's nice to
        have a console always available for debugging.

        To start your app with iex:

            $ iex -S mix

        To start your app with mix:

            $ mix run --no-halt

        Now you should be able to hit `localhost:4000`:

            $ curl http://localhost:4000/
            hello world!%

    6.7. FULFILLING THE INTENDED PURPOSE

        This is great and all, but we haven't done what we set out to do yet.
        Right now we're not taking any input, we're just displaying the same
        static message every time. Let's parse the query string and look for
        `name`:

            get "/" do
              conn = fetch_params(conn)
              case conn.params do
                %{"name" => user} -> send_resp(conn, 200, "hello #{user}!")
                _ -> send_resp(conn, 400, "bad request, need ?name querystring")
              end
            end

        Hooray, we actually got to use pattern matching! What we're doing here
        is fetching the URL parameters (query string data), and then switching
        on it.  If the `conn.params` value is a map with a `name` key, then the
        first case will match and the value will be assigned to the variable
        `user`. If the case does not match, it will fall back to the underscore
        ("any") match.  Basically, this is a minimal form of error checking;
        we're ensuring that the `name` query parameter exists, and assigning it
        the variable `user`.

        One problem here is the map has to *exactly* match. If there are
        multuple query parameters, the fallback case will be triggered, because
        the map doesn't have the *exact* structure we specified. This is totally
        fine for now, especially for the purposes of this example, but is
        nonetheless something to keep in mind.

        Now we should be able to run our app again and this time add a query
        string:

            $ iex -S mix

            $ curl http://localhost:4000/?name=Alex
            hello Alex!%

    6.8. DEPLOYING

        Erlang's release and deployment is one of its strongest points, in my
        opinion. A "release" is a pre-compiled tarball containing the Erlang
        (and Elixir) runtime binaries and your app binaries. This means that for
        deployment, you just need to extract the tarball to any system similar
        to the one it was compiled on, and the app will run without the need to
        install anything.

        However, "traditional" deployment methods require a fair bit of setup,
        and are prone to be slightly annoying, especially if you're just
        starting out.

        So we're going to go 100% webscale and deploy our app to "the cloud." In
        this case, Heroku.

        HashNuke has a buildpack for Elixir on Heroku, so deployment should be
        as easy as:

            $ heroku create --buildpack "https://github.com/HashNuke/heroku-buildpack-elixir.git"
            $ git push heroku master

      6.8.1. FOR THE CURIOUS

          If you're feeling adventurous, you can attempt to deploy an Elixir app
          using the more traditional Erlang release tools. Luckily, as with many
          Elixir things, there is a library that abstracts away a lot of the
          pain.

          `exrm`[4] is a very nice tool that works in most cases without the
          need for any configuration at all.

          Since our app is so small, deploying in this regard is a little
          out-of-scope, but I'll leave it up to you to explore on your own, if
          Heroku isn't your jam (I tend to shy away from Heroku for its
          inflexibility in the granularity required to efficiently scale Erlang
          applications, but that's for another article).

7.0. CONGRATULATIONS AND WHERE TO GO NEXT

    Congratulations! You have now planned, built, and deployed your first Elixir
    (and therefore also Erlang) application! I hope it exceeded your wildest
    dreams.

    From here, I recommend to just start reading. You've had a taste for flesh,
    but now it is time to research -- just have a gander through the Elixir
    docs; half the battle is just finding little gems in the Kernel module that
    will make certain tasks much faster and easier.

    Best of luck with your new best friends, Elixir and Erlang.

---

[1] https://www.erlang-solutions.com/downloads/download-erlang-otp
[2] https://github.com/elixir-lang/elixir/releases
[3] https://www.alexblackie.com/mix-you-some-elixir/cheating.tar.gz
[4] https://github.com/bitwalker/exrm

</body>

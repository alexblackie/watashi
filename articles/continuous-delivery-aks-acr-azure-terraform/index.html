<p>
	Azure has some great features, and leads the industry in a few different
	ways, especially around region support and disaster recovery. But, as with
	everything, all these great features comes tradeoffs. Azure Active
	Directory (AAD) is one of those tradeoffs.
</p>

<p>
	Our story begins with configuring continuous delivery. It was all going
	smoothly until we had to authenticate with Azure Container Registry (ACR)
	and Azure Kubernetes Service (AKS). What, in AWS, would have just been an
	IAM role, in Azure is a full "Enterprise Application" within AAD.
</p>

<p>
	This "Enterprise Application" is a full-blown (private) Azure Marketplace
	OAuth2 integration. You can take this thing as far as building an entire
	product on top of Azure. However, in our case, we just want to push some
	Docker containers from CI.
</p>

<p>
	To make things worse, finding examples or documentation on building
	restrictive application roles can be often fruitless. Almost every blog
	post, documentation page, or StackOverflow answer just had the bare example
	using the Azure CLI:
</p>

<pre><code>$ az ad sp create-for-rbac --subscription &lt;id&gt;</code></pre>

<p>
	This command will automatically create an Enterprise Application and a
	Service Principal behind the scenes, and then spit out the credentials for
	it right away. Easy, right?
</p>

<p>
	Well, by default it will be scoped to the entire subscription, which means
	it will have full, unfettered access to every resource in your
	subscription. It's basically like deploying a web app using
	<code>root</code>. If these credentials leak, it could bring down your
	entire stack, or possibly even your entire company.
</p>

<p>
	You can lock it down a bit using <code>--scope</code>, to scope the access
	down to even just a single resource. This is great, but not quite far
	enough. It's significantly better than access to the entire account, but
	unfettered access to a production Kubernetes cluster is also rather
	undesirable.
</p>

<p>
	We need to go deeper.
</p>

<h3> Terraforming AAD</h3>

<p>
	Luckily, there is an official <code>hashicorp/azuread</code> provider for
	Terraform! This, along with some help from the usual
	<code>hashicorp/azurerm</code> provider, will allow us to entirely
	automate, audit, and track changes to our AAD service principals.
</p>

<p>
	The first step is to get the Application and Service Principal created.
	That is fairly straightforward:
</p>

$(highlight hcl <<'EOCODE'
resource "azuread_application" "appcd" {
  display_name = "MyAppCD${terraform.workspace}"
}

resource "azuread_service_principal" "appcd" {
  application_id = azuread_application.appcd.application_id
}

resource "azuread_application_password" "appcd" {
  application_object_id = azuread_application.appcd.object_id
  end_date_relative     = "8766h" # 1.00068 years
}
EOCODE
)

<p>
	Nothing should be too surprising here. The "application password" is
	equivalent to the "client secret". It will be generated for us, and we'll
	use an <code>output</code> later to get access to its value.
</p>

<p>
	The fun begins when we start to define some custom roles. This is why we're
	here in the first place: we want to apply only the most minimal set of
	permissions to allow CI to roll out containers and update our Kubernetes
	deployments.
</p>

<p>
	Let's start with Azure Container Registry:
</p>

$(highlight hcl <<'EOCODE'
# Similar to the built-in "AcrPush", but also allows queuing remote builds.
resource "azurerm_role_definition" "acrBuild" {
  name  = "MyAppACRBuild${terraform.workspace}"
  scope = azurerm_resource_group.main.id

  permissions {
    actions = [
      "Microsoft.ContainerRegistry/registries/read",
      "Microsoft.ContainerRegistry/registries/pull/read",
      "Microsoft.ContainerRegistry/registries/push/write",
      "Microsoft.ContainerRegistry/registries/scheduleRun/action",
      "Microsoft.ContainerRegistry/registries/runs/*",
      "Microsoft.ContainerRegistry/registries/listBuildSourceUploadUrl/action",
    ]

    not_actions = []
  }
}
EOCODE
)

<p>
	We rely quite heavily on ACR's "runs", which are remote-builds of
	containers within ACR's infrastructure. This is much safer than building
	them on CI as it can be done entirely within Azure instead of on some
	shared CI platform. It also means we don't have to worry about pushing
	images around or dealing with registry credentials in CI.
</p>

<p>
	This role is a bit "loose" in that it also allows traditional push/pull
	access, but this should be fine, as it's not opening up any more
	capability. If we need to, for whatever reason, switch to local container
	builds in CI, I don't want to have to bother with changing the role just
	for that.
</p>

<p>
	Once we have our containers, we need to access AKS. This is where the
	custom roles really shine. Before, we would have had to have given full
	cluster access just so CI could update some image tags. Now, we can lock
	things down rather tightly:
</p>

$(highlight hcl <<'EOCODE'
resource "azurerm_role_definition" "aksDeploy" {
  name  = "MyAppAKSDeploy${terraform.workspace}"
  scope = azurerm_resource_group.main.id

  permissions {
    actions = [
      "Microsoft.ContainerService/managedClusters/read",
      "Microsoft.ContainerService/managedClusters/accessProfiles/listCredential/action",
    ]

    data_actions = [
      "Microsoft.ContainerService/managedClusters/apps/deployments/read",
      "Microsoft.ContainerService/managedClusters/apps/deployments/write",
    ]

    not_actions = []
  }
}
EOCODE
)

<p>
	This policy allows our Service Principal to <strong>only</strong> get their
	credentials, and read and write to deployments. They can't delete anything,
	can't create new resources, only updates and only to deployments.
</p>

<p>
	This is still "open" in that we aren't specifying <em>which
		deployments</em> it should update, but this is still much better than
	anything else I've seen so far. There is likely a way for us to take this
	further, but for now this is sufficient.
</p>

<p>
	Which leads us to the assignments. The Role Assignments are where we can
	lock things down even further by only scoping these permissions down to
	specific resources.
</p>

$(highlight hcl <<'EOCODE'
resource "azurerm_role_assignment" "appcdAKS" {
  scope              = azurerm_kubernetes_cluster.main.id
  role_definition_id = azurerm_role_definition.aksDeploy.role_definition_resource_id
  principal_id       = azuread_service_principal.appcd.id
}

resource "azurerm_role_assignment" "appcdACR" {
  scope              = azurerm_container_registry.main.id
  role_definition_id = azurerm_role_definition.acrBuild.role_definition_resource_id
  principal_id       = azuread_service_principal.appcd.id
}
EOCODE
)

<p>
	With this, we should have everything we need. We can then assemble an
	output with the equivalent JSON blob that the <code>az</code> command line
	spits out:
</p>

$(highlight hcl <<'EOCODE'
data "azurerm_subscription" "primary" { }

output "appcd_service_principal" {
  value = <<EOF
{
  "clientId": "${azuread_application.appcd.application_id}",
  "clientSecret": "${azuread_application_password.appcd.value}",
  "subscriptionId": "${data.azurerm_subscription.primary.subscription_id}",
  "tenantId": "${data.azurerm_subscription.primary.tenant_id}",
  "activeDirectoryEndpointUrl": "https://login.microsoftonline.com",
  "resourceManagerEndpointUrl": "https://management.azure.com/",
  "activeDirectoryGraphResourceId": "https://graph.windows.net/",
  "sqlManagementEndpointUrl": "https://management.core.windows.net:8443/",
  "galleryEndpointUrl": "https://gallery.azure.com/",
  "managementEndpointUrl": "https://management.core.windows.net/"
}
  EOF
}
EOCODE
)

<p>
	This JSON blob will be output at the end of <code>terraform apply</code>
	with all the right values populated. Take it, put it in a secret, and then
	you can use it to authenticate with Azure from CI and deploy what you need.
</p>

<h3>Where to go from here</h3>

<p>
	Azure AD is a complex and often unforgiving beast. But given a lot of time
	and learning, it can be honed into a very powerful tool that makes you and
	your infrastructure safer.
</p>

<p>
	Getting this far took many hours of trial-and-error and research. It was
	not a particularly pleasant process. However, the result was worth it, and
	I'm pretty happy with how it turned out.
</p>

<p>
	Figuring out which actions you need is by far the worst part of this process.
	Perhaps the best resource is <a href="https://docs.microsoft.com/en-us/azure/role-based-access-control/resource-provider-operations">this enormous list of every <code>action</code> in Azure</a>.
	It's a lot to search through, but you can usually figure out which ones you
	want.
</p>

<p>
	And, if it comes down to it, the errors returned by Azure when you are
	missing a permission often include the exact action required so you can
	just copy-and-paste that into your role and try again.
</p>

<p>
	Hopefully you were able to take something from this article, and here's to
	more secure deployments.
</p>
